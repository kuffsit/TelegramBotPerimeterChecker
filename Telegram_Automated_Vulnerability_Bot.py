import os
import requests
import subprocess
import time
import tempfile
import logging
import urllib3

# Отключаем предупреждения об SSL-сертификатах
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Настройка логирования
logging.basicConfig(filename='scan_log.log', level=logging.DEBUG,
                    format='%(asctime)s %(levelname)s:%(message)s')

# Ваши токены и Chat ID
telegram_token = 'YOUR_TELEGRAM_BOT_TOKEN'
chat_id = 'YOUR_CHAT_ID'  # Ваш ID группы

# Домены для проверки
domains = ['example.com', 'example.com1', 'example.com2', 'example.com3', 'example.com4']

# Функция отправки сообщений в Telegram
def send_telegram_message(message):
    url = f'https://api.telegram.org/bot{telegram_token}/sendMessage'
    payload = {
        'chat_id': chat_id,
        'text': message,
        'parse_mode': 'HTML'
    }
    try:
        response = requests.post(url, data=payload)
        response_data = response.json()
        if response_data.get("ok"):
            logging.info("Сообщение успешно отправлено в Telegram.")
        else:
            logging.error(f'Ошибка при отправке сообщения в Telegram: {response_data}')
    except Exception as e:
        logging.error(f'Ошибка при отправке сообщения в Telegram: {e}')

# Функция отправки файла в Telegram
def send_file_to_telegram(file_path):
    url = f'https://api.telegram.org/bot{telegram_token}/sendDocument'
    with open(file_path, 'rb') as file:
        files = {'document': file}
        data = {'chat_id': chat_id}
        try:
            response = requests.post(url, files=files, data=data)
            response_data = response.json()
            if response_data.get("ok"):
                logging.info("Файл успешно отправлен в Telegram.")
            else:
                logging.error(f'Ошибка при отправке файла в Telegram: {response_data}')
        except Exception as e:
            logging.error(f'Ошибка при отправке файла в Telegram: {e}')

# Функция получения субдоменов с использованием Subfinder
def get_subdomains(domain):
    try:
        # Команда для запуска Subfinder
        command = f"subfinder -d {domain} -silent"
        result = subprocess.run(command.split(), capture_output=True, text=True)
        
        # Собираем субдомены из результата
        subdomains = set(result.stdout.splitlines())
        if subdomains:
            logging.info(f'Найдено {len(subdomains)} субдоменов для {domain} с помощью Subfinder.')
            return list(subdomains)
        else:
            logging.warning(f'Не удалось получить субдомены для {domain} с использованием Subfinder.')
            return []
    except Exception as e:
        logging.error(f'Ошибка при получении субдоменов для {domain} с использованием Subfinder: {e}')
        return []

# Функция проверки доступности сайта
def is_site_up(subdomain):
    try:
        # Пробуем установить HTTPS соединение
        response = requests.get(f"https://{subdomain}", timeout=5, verify=False)
        return True
    except requests.exceptions.SSLError:
        # Если HTTPS не работает, пробуем HTTP
        try:
            response = requests.get(f"http://{subdomain}", timeout=5)
            return True
        except requests.RequestException:
            return False
    except requests.RequestException:
        return False

# Функция проверки поддоменов с использованием Nmap
def scan_ports(subdomain):
    ports = "22,23,25,53,80,110,143,443,445,993,995,3306,3389,5900,8080,8443,8000,9090,3000"
    command = f"nmap -p {ports} {subdomain} --open --no-styles"
    logging.info(f'Запуск Nmap сканирования для {subdomain}')
    result = subprocess.run(command.split(), capture_output=True, text=True)
    return result.stdout

# Функция проверки уязвимостей с использованием Nuclei
def scan_vulnerabilities(subdomain):
    command = f"nuclei -u {subdomain} -silent -no-color -severity medium,high,critical"
    logging.info(f'Запуск Nuclei сканирования для {subdomain}')
    result = subprocess.run(command.split(), capture_output=True, text=True)
    return result.stdout

# Функция для генерации HTML отчета
def generate_html_report(domain, accessible_subdomains_info):
    # Начало HTML-документа
    html_content = f"""<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Отчет по безопасности для {domain}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        h1 {{ color: #333; }}
        h2 {{ color: #555; }}
        .subdomain {{ margin-bottom: 40px; }}
        .section {{ margin-top: 20px; }}
        .ports, .vulnerabilities {{ background-color: #f9f9f9; padding: 10px; border-radius: 5px; }}
        .vulnerability {{ color: #d9534f; }}
        .no-vulnerabilities {{ color: #5cb85c; }}
        footer {{ margin-top: 50px; font-size: 0.9em; color: #777; }}
    </style>
</head>
<body>

<h1>Отчет по безопасности для {domain}</h1>
"""

    for info in accessible_subdomains_info:
        subdomain = info['subdomain']
        port_scan_result = info['port_scan_result']
        vuln_scan_result = info['vuln_scan_result']

        # Парсинг открытых портов
        open_ports = []
        for line in port_scan_result.splitlines():
            if '/tcp' in line and 'open' in line:
                parts = line.split()
                port_service = f"{parts[0]} ({parts[2]})" if len(parts) >= 3 else parts[0]
                open_ports.append(port_service)

        # Обработка уязвимостей
        vulnerabilities = vuln_scan_result.strip().splitlines() if vuln_scan_result else []

        # Добавление информации о субдомене в HTML
        html_content += f"""
<div class="subdomain">
    <h2>{subdomain}</h2>
    <div class="section">
        <strong>Открытые порты:</strong>
        <div class="ports">
"""
        for port in open_ports:
            html_content += f"            <p>{port}</p>\n"

        html_content += """        </div>
    </div>
    <div class="section">
        <strong>Обнаруженные уязвимости:</strong>
        <div class="vulnerabilities">
"""

        if vulnerabilities:
            for vuln in vulnerabilities:
                html_content += f'            <p class="vulnerability">{vuln}</p>\n'
        else:
            html_content += '            <p class="no-vulnerabilities">Уязвимости не обнаружены.</p>\n'

        html_content += """        </div>
    </div>
</div>
"""

    # Завершение HTML-документа
    html_content += f"""
<footer>
    Отчет сгенерирован: {time.strftime('%Y-%m-%d %H:%M:%S')}
</footer>

</body>
</html>
"""

    return html_content

# Основная функция для генерации отчета
def generate_report(domain):
    accessible_subdomains_info = []
    summary = f"<b>Отчет по домену {domain}</b>\n\n"

    subdomains = get_subdomains(domain)
    if not subdomains:
        summary += "Не найдено активных субдоменов.\n"
    else:
        for subdomain in subdomains:
            if is_site_up(subdomain):
                port_scan_result = scan_ports(subdomain)
                vuln_scan_result = scan_vulnerabilities(subdomain)

                vuln_count = vuln_scan_result.count('\n') if vuln_scan_result else 0
                open_ports = ', '.join([line.split('/')[0] for line in port_scan_result.splitlines() if '/tcp' in line and 'open' in line])

                summary += f"- <b>{subdomain}</b> — {vuln_count} уязвимостей, открытые порты: {open_ports}\n"

                accessible_subdomains_info.append({
                    'subdomain': subdomain,
                    'port_scan_result': port_scan_result,
                    'vuln_scan_result': vuln_scan_result
                })
            else:
                logging.info(f'Субдомен {subdomain} недоступен и будет пропущен.')

        if not accessible_subdomains_info:
            summary += "Не найдено доступных субдоменов.\n"

    summary += f"\nОтчет сгенерирован: {time.strftime('%Y-%m-%d %H:%M:%S')}"

    # Генерация HTML-отчета
    html_report = generate_html_report(domain, accessible_subdomains_info)

    # Сохранение HTML-отчета во временный файл
    with tempfile.NamedTemporaryFile(delete=False, mode='w', suffix='.html') as temp_file:
        temp_file.write(html_report)
        temp_file_path = temp_file.name

    # Отправка краткого отчета в Telegram
    if len(summary) < 4096:  # Ограничение Telegram на длину сообщения
        send_telegram_message(summary)
    else:
        logging.warning('Краткий отчет слишком длинный для отправки в Telegram.')

    # Отправляем HTML-файл отчета в Telegram
    send_file_to_telegram(temp_file_path)

    # Удаление временного файла
    os.remove(temp_file_path)

# Выполнение проверки и генерация отчета для каждого домена
for domain in domains:
    try:
        generate_report(domain)
    except Exception as e:
        logging.error(f'Ошибка при генерации отчета для {domain}: {e}')
